import os
import glob
import PIL.Image
import OpenEXR, Imath
import numpy as np
import imgaug as ia
import imgaug.augmenters as iaa

############################################################
#  Dataset
############################################################


class AutoGeneratedDataset:
    def __init__(self, data_root, class_names, rgb_extension='rgb.png', 
        d_extension='depth.exr', mask_extension='alpha.png', background_paths=None, depth=True):
        """Load a subset of the auto-generated dataset from 3D Object
        """

        self.root = data_root
        self.rgb_extension = rgb_extension
        self.d_extension = d_extension
        self.mask_extension = mask_extension        
        self.background_paths = background_paths
        self.depth = depth
        # get classes
        self.class_names = ['background'] + class_names
        self.class_name2id = {v:k for k,v in enumerate(self.class_names)}

        sample_ids = []
        for idx, class_name in enumerate(class_names):
            class_dir = os.path.join(data_root, class_name)
            rgb_dir = os.path.join(class_dir, 'rgb')

            # Use rgb files is master source which is used to infer path of other files
            rgb_files = glob.glob(os.path.join(rgb_dir, '*' + rgb_extension))
            # note that the file name format is [class_name].[id].rgb.png
            for fn in rgb_files:
                file_com = os.path.basename(fn).split(sep='.')
                sample_id = f'{class_name}.{file_com[1]}'
                sample_ids.append(sample_id)

        self.sample_ids = sample_ids
        # use image augmentation
        # Sometimes(0.5, ...) applies the given augmenter in 50% of all cases,
        # e.g. Sometimes(0.5, GaussianBlur(0.3)) would blur roughly every second image.
        def sometimes(aug): return iaa.Sometimes(0.25, aug)
        self.both_aug = sometimes(iaa.Affine(
            # scale images to 80-120% of their size, individually per axis
            scale={"x": (0.8, 1.2), "y": (0.8, 1.2)},
            # translate by -20 to +20 percent (per axis)
            translate_percent={"x": (-0.2, 0.2), "y": (-0.2, 0.2)},
            rotate=(-30, 30),  # rotate by -45 to +45 degrees
            # use nearest neighbour or bilinear interpolation (fast)
            order=[0, 1],
            cval=0,  # if mode is constant, use a cval between 0 and 255
            # use any of scikit-image's warping modes (see 2nd image from the top for examples)
            mode='constant'
        ))

        self.rgb_aug = iaa.Sequential([
            sometimes(iaa.Dropout(per_channel=True, p=0.08)),
            iaa.GaussianBlur(sigma=(0, 1.0)),
            sometimes(iaa.Add((-40, 40))),
            sometimes(iaa.AddToHueAndSaturation((-20, 20))),
            sometimes(iaa.GammaContrast(gamma=(0.50, 2.50)))
        ], random_order=True)

        self.d_aug = iaa.Sequential([
            AddFloat((-0.1, 0.8)),
            iaa.GaussianBlur(sigma=(0, 0.4)),
            iaa.Dropout(p=0.12),
        ])
        

    def __len__(self):
        return len(self.sample_ids)

    def __getitem__(self, index):
        # asseemble paths
        sample_id = self.sample_ids[index]
        class_name = sample_id.split('.')[0]
        class_dir = os.path.join(self.root, class_name)
        rgb_dir = os.path.join(class_dir, 'rgb')
        rgb_file = os.path.join(rgb_dir, f'{sample_id}.{self.rgb_extension}')
        rgb_mask_file = os.path.join(rgb_dir, f'{sample_id}.{self.mask_extension}')

        # load image, mask and depth
        np_rgb_mask = load_mask(rgb_mask_file) # dtype=bool
        # background
        background_file = None
        if self.background_paths is not None and len(self.background_paths) > 0:
            selected_background_index = np.random.randint(0, len(self.background_paths))
            background_file = self.background_paths[selected_background_index]
        
        np_rgb = load_rgb(rgb_file, np_rgb_mask, background_file) # dtype=uint8
        np_ids = np.array([self.class_name2id[class_name]], dtype=np.int32)

        # augmentating data
        np_rgb = self.rgb_aug.augment_image(np_rgb)
        both_det = self.both_aug.to_deterministic()
        np_rgb = both_det.augment_image(np_rgb)
        np_rgb_mask = np_rgb_mask.astype(np.uint8)
        np_rgb_mask = both_det.augment_image(np_rgb_mask).astype(np.bool)
        
        # clamp and normalize to [-1, 1]
        np_rgb = (np_rgb.astype(np.float32) - 127.0) / 127.0

        # for DEPTH:
        if self.depth:
            # path
            d_dir = os.path.join(class_dir, 'd')
            d_file = os.path.join(d_dir, f'{sample_id}.{self.d_extension}')
            d_mask_file = os.path.join(d_dir, f'{sample_id}.{self.mask_extension}')

            # load
            np_d = load_exr(d_file) # dtype=float32
            np_d_mask = load_mask(d_mask_file) # dtype=bool

            # augmentation
            np_d = self.d_aug.augment_image(np_d)
            np_d = both_det.augment_image(np_d)
            np_d_mask = np_d_mask.astype(np.uint8)
            np_d_mask = both_det.augment_image(np_d_mask).astype(np.bool)

            # normalize
            np_d = (np.clip(np_d, 0.2, 1.2) - 0.7) / 0.5 # range from 0.2m to 1.2m

            # aggregate data
            np_image = np.concatenate((np_rgb, np_d), axis=2)
            np_masks = np.stack((np_rgb_mask, np_d_mask), axis=-1)
            np_masks = np_masks[:, :, None, :]
        else:
            np_image = np_rgb
            np_masks = np_rgb_mask[:, :, None, None]

        return np_image, np_masks, np_ids

def load_rgb(path, mask=None, background_path=None):
    pil_image = PIL.Image.open(path)
    if pil_image.mode != 'RGB':
        pil_image = pil_image.convert('RGB')

    if background_path is None:
        return np.array(pil_image)
    
    # add background
    pil_background = PIL.Image.open(background_path)
    # resize
    bg_size = pil_background.size
    desired_size = pil_image.size[0] # square image
    ratio = float(desired_size)/min(bg_size)
    new_size = tuple([int(x*ratio + 1) for x in bg_size])
    pil_background = pil_background.resize(new_size, PIL.Image.BILINEAR)
    # random crop
    left = 0 if new_size[0] == desired_size else np.random.randint(0, new_size[0] - desired_size)
    top = 0 if new_size[1] == desired_size else np.random.randint(0, new_size[1] - desired_size)
    pil_background = pil_background.crop((left, top, left + desired_size, top + desired_size))

    # convert RGB if background is not
    if pil_background.mode != 'RGB':
        pil_background = pil_background.convert('RGB')
        
    # to numpy
    np_background = np.array(pil_background, dtype=np.uint8)
    np_image = np.array(pil_image, dtype=np.uint8)
        
    # copy image to background
    np_combined = np.copy(np_background)
    np_combined[mask] = np_image[mask]

    return np_combined

def load_mask(path):
    # Note: assume that mask images have same size and as its RGB image
    mask_image = PIL.Image.open(path)
    if mask_image.mode == 'L':
        mask_image = mask_image.convert('1')
    elif mask_image.mode != '1':
        mask_image = mask_image.convert('L', dither=None).convert('1')
    mask = np.array(mask_image)

    return mask

def load_exr(path):
    depth_file = OpenEXR.InputFile(path)
    header = depth_file.header()
    datawin = header['dataWindow']
    image_size = (datawin.max.x + 1, datawin.max.y + 1)

    FLOAT = Imath.PixelType(Imath.PixelType.FLOAT)
    r = depth_file.channel('R', FLOAT)
    np_depth = np.frombuffer(r, dtype=np.float32).reshape((image_size[1], image_size[0], 1))

    depth_file.close()

    return np_depth

class AddFloat(iaa.Augmenter):
    def __init__(self, value, name=None, deterministic=False, random_state=None):
        super(AddFloat, self).__init__(
            name=name, deterministic=deterministic, random_state=random_state)
        self.value = value

    def _augment_images(self, images, random_state, parents, hooks):
        n_images = len(images)
        add_values = random_state.uniform(low=self.value[0], high=self.value[1], size=n_images)
        dest_images = []
        for idx in range(n_images):
            dest_images.append(images[idx] + add_values[idx])

        return images

    def _augment_heatmaps(self, heatmaps, random_state, parents, hooks):
        return heatmaps

    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):
        return keypoints_on_images
    
    def get_parameters(self):
        return [self.image_paths]

if __name__ == "__main__":
    dataset = AutoGeneratedDataset(r'D:\tranduytrung\Mask_RCNN\auto-generated\train', ['1'])
    x= dataset[0]
    x= dataset[1]